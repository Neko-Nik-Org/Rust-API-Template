use serde::{Deserialize, Serialize};
use deadpool_postgres::Pool as PgPool;


#[derive(Deserialize, Serialize)]
pub struct Note {
    title: String,
    content: String,
}

// The reason why we created a separate struct for Record is because id is
// auto-generated by the database and can't be inserted manually, else we
// could have used Note struct for Record as well
#[derive(Serialize, Deserialize)]
pub struct Record {
    pub id: i32,
    pub title: String,
    pub content: String,
}


// DB working state Check
pub async fn health_check(db_pool: &PgPool) -> Result<(), deadpool_postgres::PoolError> {
    // Simple query to check if the database is responsive
    let client = db_pool.get().await?;
    let _ = client.query("SELECT 1", &[]).await?;
    Ok(())
}


// Sample private function to create a new note
// async fn create_single_note(db_pool: &PgPool, note: Note) -> Result<i32, deadpool_postgres::PoolError> {
//     let client = db_pool.get().await?;
//     let row = client
//         .query(
//             r#"
//             INSERT INTO notes (title, content)
//             VALUES ($1, $2)
//             RETURNING id
//             "#,
//             &[&note.title, &note.content],
//         )
//         .await?;

//     Ok(row.get("id"))
// }


// // Add few sample data in DB
// pub async fn add_new_notes(db_pool: &PgPool, values: Vec<Note>) -> Result<(), sqlx::Error> {
//     for note in values {
//         // We can do like this to purely put the query in one function and call it in another function
//         // We can even do some processing before calling the query (but all db related stuff should be in db module only)
//         create_single_note(db_pool, note).await?;
//     }

//     Ok(())
// }

// // Fetch all notes from DB
// pub async fn fetch_all_notes(db_pool: &PgPool) -> Result<Vec<Record>, sqlx::Error> {
//     let result = sqlx::query(
//         r#"
//         SELECT id, title, content FROM notes
//         "#
//     )
//     .map(|row: sqlx::postgres::PgRow| Record {
//         id: row.get("id"),
//         title: row.get("title"),
//         content: row.get("content"),
//     })
//     .fetch_all(db_pool)
//     .await;

//     result
// }
