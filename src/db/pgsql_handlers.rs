use serde::{Deserialize, Serialize};
use sqlx::postgres::PgPool;
use sqlx::Row;


#[derive(Deserialize, Serialize)]
pub struct Note {
    title: String,
    content: String,
}

// The reason why we created a separate struct for Record is because id is
// auto-generated by the database and can't be inserted manually, else we
// could have used Note struct for Record as well
#[derive(Serialize, Deserialize)]
pub struct Record {
    pub id: i32,
    pub title: String,
    pub content: String,
}


// DB working state Check
pub async fn health_check(db_pool: &PgPool) -> Result<(), sqlx::Error> {
    // Simple query to check if the database is responsive
    sqlx::query("SELECT 1")
        .fetch_one(db_pool)
        .await
        .map(|_| ()) // If successful, return Ok(())
}


// Sample private function to create a new note
async fn create_single_note(db_pool: &PgPool, note: Note) -> Result<i32, sqlx::Error> {
    let row = sqlx::query(
        r#"
        INSERT INTO notes (title, content)
        VALUES ($1, $2)
        RETURNING id
        "#
    )
    .bind(&note.title)
    .bind(&note.content)
    .fetch_one(db_pool)
    .await?;

    Ok(row.get("id"))
}

// Add few sample data in DB
pub async fn add_new_notes(db_pool: &PgPool, values: Vec<Note>) -> Result<(), sqlx::Error> {
    for note in values {
        // We can do like this to purely put the query in one function and call it in another function
        // We can even do some processing before calling the query (but all db related stuff should be in db module only)
        create_single_note(db_pool, note).await?;
    }

    Ok(())
}

// Fetch all notes from DB
pub async fn fetch_all_notes(db_pool: &PgPool) -> Result<Vec<Record>, sqlx::Error> {
    let result = sqlx::query(
        r#"
        SELECT id, title, content FROM notes
        "#
    )
    .map(|row: sqlx::postgres::PgRow| Record {
        id: row.get("id"),
        title: row.get("title"),
        content: row.get("content"),
    })
    .fetch_all(db_pool)
    .await;

    result
}
